from __future__ import annotations

import argparse
from pathlib import Path

import pandas as pd


def parse_args() -> argparse.Namespace:
    p = argparse.ArgumentParser(description="Plot IMU CSV generated by decoder.py")
    p.add_argument("csv", type=Path, help="input CSV file (from decoder)")
    p.add_argument("--cols", type=str, default="",
                   help="comma-separated columns to plot (default: accel and gyro if present)")
    p.add_argument("--x", type=str, default="",
                   help="x-axis column (default: t_sec if present else n)")
    p.add_argument("--start", type=float, default=None,
                   help="crop start (by x-axis value if numeric)")
    p.add_argument("--end", type=float, default=None,
                   help="crop end (by x-axis value if numeric)")
    p.add_argument("--every", type=int, default=1,
                   help="plot every Nth sample for speed (default: 1 = all)")
    p.add_argument("--rolling", type=int, default=0,
                   help="optional rolling mean window (samples)")
    p.add_argument("--save", type=Path, default=None,
                   help="save figure to this path (PNG, PDF, etc.)")
    p.add_argument("--no-show", action="store_true",
                   help="do not open an interactive window (useful with --save)")
    return p.parse_args()


def ensure_matplotlib(headless: bool):
    # Import matplotlib lazily; choose Agg backend when not showing
    if headless:
        import matplotlib
        matplotlib.use("Agg")
    import matplotlib.pyplot as plt
    return plt

def install_clickable_legend(fig, ax):
    """Make legend items clickable to toggle line visibility.

    Clicking a legend line or its text toggles the corresponding plotted line.
    The legend item alpha is synced (1.0 when visible, 0.25 when hidden).
    """
    leg = ax.get_legend()
    if leg is None:
        return

    # Map labels to the underlying Line2D objects currently on the Axes
    handles, labels = ax.get_legend_handles_labels()
    line_by_label = {line.get_label(): line for line in ax.get_lines()}

    # Make legend line handles and texts pickable
    leg_lines = leg.get_lines()
    leg_texts = leg.get_texts()
    for h in (*leg_lines, *leg_texts):
        h.set_picker(True)

    # Build mapping from legend item (line/text) to the original plotted line
    handle2orig = {}
    for h, lab in zip(leg_lines, labels):
        if lab in line_by_label:
            handle2orig[h] = line_by_label[lab]
    for t, lab in zip(leg_texts, labels):
        if lab in line_by_label:
            handle2orig[t] = line_by_label[lab]

    # Build reverse mapping for alpha sync
    orig2handles = {}
    for hline, t in zip(leg_lines, leg_texts):
        lab = t.get_text()
        if lab in line_by_label:
            orig2handles[line_by_label[lab]] = (hline, t)

    def sync_legend_alpha(orig_line):
        hline, htext = orig2handles.get(orig_line, (None, None))
        if not hline or not htext:
            return
        alpha = 1.0 if orig_line.get_visible() else 0.25
        hline.set_alpha(alpha)
        htext.set_alpha(alpha)

    def on_pick(event):
        artist = event.artist
        orig = handle2orig.get(artist)
        if orig is None:
            return
        orig.set_visible(not orig.get_visible())
        sync_legend_alpha(orig)
        fig.canvas.draw_idle()

    # Initial sync for current visibility
    for orig in orig2handles.keys():
        sync_legend_alpha(orig)
    fig.canvas.mpl_connect('pick_event', on_pick)


def pick_default_cols(df: pd.DataFrame) -> list[str]:
    acc = [c for c in ("ax_g", "ay_g", "az_g") if c in df.columns]
    gyr = [c for c in ("gx_dps", "gy_dps", "gz_dps") if c in df.columns]
    if acc and gyr:
        return acc + gyr
    return acc or gyr or [c for c in df.columns if c not in {"n", "t_sec"}]


def main():
    args = parse_args()

    df = pd.read_csv(args.csv)
    xcol = args.x or ("t_sec" if "t_sec" in df.columns else "n")
    if xcol not in df.columns:
        raise SystemExit(f"x-axis column '{xcol}' not found in {args.csv}")

    # Select y columns
    if args.cols:
        ycols = [c.strip() for c in args.cols.split(",") if c.strip()]
    else:
        ycols = pick_default_cols(df)
    missing = [c for c in ycols if c not in df.columns]
    if missing:
        raise SystemExit(f"columns not found in CSV: {missing}")

    # Optional crop by x range
    if args.start is not None:
        df = df[df[xcol] >= args.start]
    if args.end is not None:
        df = df[df[xcol] <= args.end]

    # Downsample for quick plotting
    if args.every > 1:
        df = df.iloc[:: args.every, :]

    # Optional rolling mean
    if args.rolling and args.rolling > 1:
        df[ycols] = df[ycols].rolling(window=args.rolling, min_periods=1, center=False).mean()

    headless = bool(args.save) or args.no_show
    plt = ensure_matplotlib(headless=headless)

    # Layout: if both accel and gyro are present and user did not specify cols,
    # try to split into two subplots for readability
    acc_cols = [c for c in ("ax_g", "ay_g", "az_g") if c in ycols]
    gyr_cols = [c for c in ("gx_dps", "gy_dps", "gz_dps") if c in ycols]

    if not args.cols and acc_cols and gyr_cols:
        fig, axes = plt.subplots(2, 1, sharex=True, figsize=(10, 6))
        ax1, ax2 = axes
        for c in acc_cols:
            ax1.plot(df[xcol], df[c], label=c)
        ax1.set_ylabel("acc [g]")
        ax1.grid(True, alpha=0.3)
        ax1.legend(loc="upper right")
        install_clickable_legend(fig, ax1)

        for c in gyr_cols:
            ax2.plot(df[xcol], df[c], label=c)
        ax2.set_ylabel("gyro [dps]")
        ax2.set_xlabel("time [s]" if xcol == "t_sec" else xcol)
        ax2.grid(True, alpha=0.3)
        ax2.legend(loc="upper right")
        install_clickable_legend(fig, ax2)
        fig.suptitle(Path(args.csv).name)
        fig.tight_layout()
    else:
        fig, ax = plt.subplots(figsize=(10, 4))
        for c in ycols:
            ax.plot(df[xcol], df[c], label=c)
        ax.set_xlabel("time [s]" if xcol == "t_sec" else xcol)
        ax.set_ylabel("value")
        ax.grid(True, alpha=0.3)
        ax.legend(loc="upper right")
        install_clickable_legend(fig, ax)
        fig.suptitle(Path(args.csv).name)
        fig.tight_layout()

    if args.save:
        out = Path(args.save)
        out.parent.mkdir(parents=True, exist_ok=True)
        fig.savefig(out, dpi=150)
        print(f"Saved: {out}")

    if not args.no_show:
        plt.show()


if __name__ == "__main__":
    main()
